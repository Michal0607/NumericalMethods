<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Projekt z Metod Numerycznych</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Omówienie_files/libs/clipboard/clipboard.min.js"></script>
<script src="Omówienie_files/libs/quarto-html/quarto.js"></script>
<script src="Omówienie_files/libs/quarto-html/popper.min.js"></script>
<script src="Omówienie_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Omówienie_files/libs/quarto-html/anchor.min.js"></script>
<link href="Omówienie_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Omówienie_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Omówienie_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Omówienie_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Omówienie_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#wstęp" id="toc-wstęp" class="nav-link active" data-scroll-target="#wstęp">Wstęp</a>
  <ul class="collapse">
  <li><a href="#charakterystyka-problemu" id="toc-charakterystyka-problemu" class="nav-link" data-scroll-target="#charakterystyka-problemu">Charakterystyka Problemu</a></li>
  <li><a href="#cel-i-zakres-projektu" id="toc-cel-i-zakres-projektu" class="nav-link" data-scroll-target="#cel-i-zakres-projektu">Cel i Zakres Projektu</a></li>
  <li><a href="#podstawowe-informacje-na-temat-użytych-metod" id="toc-podstawowe-informacje-na-temat-użytych-metod" class="nav-link" data-scroll-target="#podstawowe-informacje-na-temat-użytych-metod">Podstawowe Informacje na Temat Użytych Metod</a></li>
  </ul></li>
  <li><a href="#analiza-teoretyczna" id="toc-analiza-teoretyczna" class="nav-link" data-scroll-target="#analiza-teoretyczna">Analiza Teoretyczna</a>
  <ul class="collapse">
  <li><a href="#przegląd-metod-numerycznych" id="toc-przegląd-metod-numerycznych" class="nav-link" data-scroll-target="#przegląd-metod-numerycznych">Przegląd Metod Numerycznych</a></li>
  <li><a href="#matematyczne-podstawy-i-założenia" id="toc-matematyczne-podstawy-i-założenia" class="nav-link" data-scroll-target="#matematyczne-podstawy-i-założenia">Matematyczne Podstawy i Założenia</a></li>
  <li><a href="#analiza-zbieżności-stabilności-i-dokładności" id="toc-analiza-zbieżności-stabilności-i-dokładności" class="nav-link" data-scroll-target="#analiza-zbieżności-stabilności-i-dokładności">Analiza Zbieżności, Stabilności i Dokładności</a></li>
  </ul></li>
  <li><a href="#opis-implementacji" id="toc-opis-implementacji" class="nav-link" data-scroll-target="#opis-implementacji">Opis implementacji</a></li>
  <li><a href="#testowanie" id="toc-testowanie" class="nav-link" data-scroll-target="#testowanie">Testowanie</a></li>
  <li><a href="#wyniki-i-dyskusja" id="toc-wyniki-i-dyskusja" class="nav-link" data-scroll-target="#wyniki-i-dyskusja">Wyniki i dyskusja</a></li>
  <li><a href="#zbiór-danych-breast_cancer" id="toc-zbiór-danych-breast_cancer" class="nav-link" data-scroll-target="#zbiór-danych-breast_cancer">Zbiór danych <code>breast_cancer</code></a>
  <ul class="collapse">
  <li><a href="#pca" id="toc-pca" class="nav-link" data-scroll-target="#pca">PCA</a></li>
  <li><a href="#svd" id="toc-svd" class="nav-link" data-scroll-target="#svd">SVD</a></li>
  <li><a href="#porównanie" id="toc-porównanie" class="nav-link" data-scroll-target="#porównanie">Porównanie</a></li>
  </ul></li>
  <li><a href="#zbiór-danych-iris" id="toc-zbiór-danych-iris" class="nav-link" data-scroll-target="#zbiór-danych-iris">Zbiór danych <code>iris</code></a>
  <ul class="collapse">
  <li><a href="#pca-1" id="toc-pca-1" class="nav-link" data-scroll-target="#pca-1">PCA</a></li>
  <li><a href="#svd-1" id="toc-svd-1" class="nav-link" data-scroll-target="#svd-1">SVD</a></li>
  <li><a href="#porównanie-1" id="toc-porównanie-1" class="nav-link" data-scroll-target="#porównanie-1">Porównanie</a></li>
  </ul></li>
  <li><a href="#zbiór-danych-titanic" id="toc-zbiór-danych-titanic" class="nav-link" data-scroll-target="#zbiór-danych-titanic">Zbiór danych <code>titanic</code></a>
  <ul class="collapse">
  <li><a href="#pca-2" id="toc-pca-2" class="nav-link" data-scroll-target="#pca-2">PCA</a></li>
  <li><a href="#svd-2" id="toc-svd-2" class="nav-link" data-scroll-target="#svd-2">SVD</a></li>
  <li><a href="#porównanie-2" id="toc-porównanie-2" class="nav-link" data-scroll-target="#porównanie-2">Porównanie</a></li>
  </ul></li>
  <li><a href="#efekty-użycia-pca-i-svd-w-uczeniu-maszynowym" id="toc-efekty-użycia-pca-i-svd-w-uczeniu-maszynowym" class="nav-link" data-scroll-target="#efekty-użycia-pca-i-svd-w-uczeniu-maszynowym">Efekty użycia PCA i SVD w uczeniu maszynowym</a>
  <ul class="collapse">
  <li><a href="#wstęp-1" id="toc-wstęp-1" class="nav-link" data-scroll-target="#wstęp-1">Wstęp</a></li>
  <li><a href="#heloc---opis-zbioru-danych" id="toc-heloc---opis-zbioru-danych" class="nav-link" data-scroll-target="#heloc---opis-zbioru-danych">Heloc - opis zbioru danych</a></li>
  <li><a href="#przegląd-eksperymentów" id="toc-przegląd-eksperymentów" class="nav-link" data-scroll-target="#przegląd-eksperymentów">Przegląd Eksperymentów</a></li>
  <li><a href="#wyniki-i-analiza" id="toc-wyniki-i-analiza" class="nav-link" data-scroll-target="#wyniki-i-analiza">Wyniki i Analiza</a></li>
  <li><a href="#dyskusja" id="toc-dyskusja" class="nav-link" data-scroll-target="#dyskusja">Dyskusja</a></li>
  <li><a href="#wnioski" id="toc-wnioski" class="nav-link" data-scroll-target="#wnioski">Wnioski</a></li>
  <li><a href="#zalecenia" id="toc-zalecenia" class="nav-link" data-scroll-target="#zalecenia">Zalecenia</a></li>
  </ul></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projekt z Metod Numerycznych</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="wstęp" class="level1">
<h1>Wstęp</h1>
<section id="charakterystyka-problemu" class="level2">
<h2 class="anchored" data-anchor-id="charakterystyka-problemu">Charakterystyka Problemu</h2>
<p>W uczeniu maszynowym jednym z kluczowych wyzwań jest efektywne przetwarzanie dużych zestawów danych, które często zawierają wiele zbędnych lub skorelowanych cech. Redukcja wymiarowości jest techniką przetwarzania wstępnego, która pomaga w redukcji liczby zmiennych wejściowych, zachowując przy tym jak najwięcej informacji zawartych w danych. Stosowanie tej techniki może znacząco poprawić wydajność algorytmów uczenia maszynowego poprzez zmniejszenie złożoności obliczeniowej oraz pomóc w uniknięciu nadmiaru wymiarowości.</p>
</section>
<section id="cel-i-zakres-projektu" class="level2">
<h2 class="anchored" data-anchor-id="cel-i-zakres-projektu">Cel i Zakres Projektu</h2>
<p>Celem projektu jest zaimplementowanie i zastosowanie dwóch technik numerycznych: Analizy Głównych Składowych (PCA) oraz Rozkładu na Wartości Osobliwe (SVD) do redukcji wymiarów danych. Projekt będzie oceniał skuteczność tych metod w kontekście poprawy wydajności modeli uczenia maszynowego oraz wizualizacji danych wielowymiarowych.</p>
</section>
<section id="podstawowe-informacje-na-temat-użytych-metod" class="level2">
<h2 class="anchored" data-anchor-id="podstawowe-informacje-na-temat-użytych-metod">Podstawowe Informacje na Temat Użytych Metod</h2>
<ul>
<li><strong>PCA (Principal Component Analysis)</strong>: Metoda statystyczna, która przekształca początkowe, skorelowane zmienne w nowy zestaw zmiennych, które są liniowo niezależne (składowe główne). Składowe te są uzyskiwane na podstawie wartości własnych macierzy kowariancji danych.</li>
<li><strong>SVD (Singular Value Decomposition)</strong>: Technika matematyczna używana do dekompozycji macierzy na trzy inne macierze, ujawniająca wewnętrzną strukturę danych, która może być użyteczna w redukcji wymiarów oraz innych zastosowaniach takich jak kompresja danych czy usuwanie szumów.</li>
</ul>
</section>
</section>
<section id="analiza-teoretyczna" class="level1">
<h1>Analiza Teoretyczna</h1>
<section id="przegląd-metod-numerycznych" class="level2">
<h2 class="anchored" data-anchor-id="przegląd-metod-numerycznych">Przegląd Metod Numerycznych</h2>
<p>Analiza Głównych Składowych (PCA) i Rozkład na Wartości Osobliwe (SVD) to dwie kluczowe metody redukcji wymiarowości w analizie danych. Obydwie techniki stosują przekształcenie liniowe, ale korzystają z różnych podejść matematycznych. PCA skupia się na wyznaczaniu głównych składowych poprzez analizę wariancji i jest często używana do zachowania jak największej ilości informacji. SVD natomiast dekomponuje macierze na wartości osobliwe oraz lewe i prawe wektory osobliwe, co pozwala na zastosowanie w różnorodnych kontekstach, w tym uczeniu maszynowym. W praktyce, PCA jest bardziej zorientowana na eksplorację danych i statystykę, podczas gdy SVD ma szersze zastosowanie, włączając w to obliczenia numeryczne. Obie metody pozwalają na identyfikację nowych osi danych, co ułatwia interpretację i analizę dużych zestawów danych. Dzięki temu, zarówno PCA jak i SVD są nieocenione w redukcji złożoności danych bez znaczącej utraty informacji.</p>
</section>
<section id="matematyczne-podstawy-i-założenia" class="level2">
<h2 class="anchored" data-anchor-id="matematyczne-podstawy-i-założenia">Matematyczne Podstawy i Założenia</h2>
<ul>
<li><strong>PCA</strong>: Analiza Głównych Składowych (PCA) jest metodą statystyczną służącą do maksymalizacji wariancji w danych. Pierwsza główna składowa, którą wyznacza PCA, charakteryzuje się największą wariancją, a każda kolejna ma mniejszą. Składowe te są matematycznie reprezentowane przez wektory własne macierzy kowariancji danych, z wartościami własnymi wskazującymi na kolejno największą do najmniejszej wariancję. Ta metoda pozwala na efektywną redukcję wymiarów, zachowując przy tym kluczowe informacje z danych.</li>
<li><strong>SVD</strong>: SVD rozkłada macierz A na trzy macierze U, <span class="math inline">\(\Sigma\)</span>, V^T, gdzie U i V są ortonormalnymi macierzami wektorów własnych, a <span class="math inline">\(\Sigma\)</span> zawiera wartości osobliwe (singular values). Wartości osobliwe wskazują na “siłę” lub “ważność” poszczególnych wymiarów.</li>
</ul>
</section>
<section id="analiza-zbieżności-stabilności-i-dokładności" class="level2">
<h2 class="anchored" data-anchor-id="analiza-zbieżności-stabilności-i-dokładności">Analiza Zbieżności, Stabilności i Dokładności</h2>
<ul>
<li><strong>PCA</strong>: Metoda Analizy Głównych Składowych (PCA) wykazuje stosunkowo dużą stabilność, jeśli dane analizowane są czyste, czyli nie zawierają znacznych ilości szumów oraz brakujących wartości. Kiedy dane są dobrze przygotowane, PCA efektywnie redukuje wymiarowość, zachowując istotne informacje. Jednakże, metoda ta może napotkać na trudności z zbieżnością i dokładnością analizy, jeśli różnice między wartościami własnymi macierzy kowariancji są minimalne. W takich przypadkach, bliskie sobie wartości własne mogą prowadzić do problemów z jednoznacznym określeniem kolejności głównych składowych, co wpływa na wyniki redukcji wymiarów.</li>
<li><strong>SVD</strong>: Rozkład na Wartości Osobliwe (SVD) charakteryzuje się większą stabilnością niż Analiza Głównych Składowych (PCA) w sytuacjach, gdy dane są zaszumione. Stabilność ta wynika z faktu, że SVD minimalizuje błąd w sensie najmniejszych kwadratów, co oznacza, że metoda ta jest bardziej odporna na zakłócenia danych. SVD jest również uważana za bardzo efektywną technikę w procesie dekompozycji macierzy, jednakże wiąże się to z większymi wymaganiami obliczeniowymi, szczególnie w przypadku analizy dużych macierzy. Ta złożoność obliczeniowa może być wyzwaniem, ale wynikające z niej korzyści często przewyższają koszty, zwłaszcza w zastosowaniach wymagających precyzyjnej analizy danych.</li>
</ul>
</section>
</section>
<section id="opis-implementacji" class="level1">
<h1>Opis implementacji</h1>
<p>Testy zostały przeprowadzone w środowisku Python, korzystając z trzech zbiorów danych: titanic, iris, breast_cancer.</p>
<ul>
<li>Zbiór danych <code>iris</code> (z biblioteki sklearn.datasets): Zawiera informacje o trzech gatunkach irysów (setosa, versicolor, virginica).Każda próbka w zbiorze posiada cztery cechy: długość i szerokość płatka oraz długość i szerokość kielicha.</li>
<li>Zbiór danych <code>breast_cancer</code> (z biblioteki sklearn.datasets): Skupia się na predykcji, czy guz piersi jest złośliwy czy łagodny, na podstawie cech takich jak tekstura, obwód, gładkość, obszar i wielkość guza, oraz inne cechy obrazu biopsji.</li>
<li>Zbiór danych <code>titanic</code> (z biblioteki seaborn): Zawiera informacje o pasażerach Titanica, takie jak wiek, płeć, klasa, której pasażerowie byli częścią, cena biletu, a także informacje o tym, czy dana osoba przeżyła katastrofę czy nie.</li>
</ul>
<p>Na każdym zbiorze danych przeprowadzono standaryzację, aby poprawić jakość i porównywalność wyników. W ramach projektu zaimplementowano dwie metody redukcji wymiarowości: Analizę Składowych Głównych (PCA) oraz Rozkład Osobliwy (SVD). Każda z metod została zastosowana osobno na każdym zbiorze danych.</p>
</section>
<section id="testowanie" class="level1">
<h1>Testowanie</h1>
<p>Porównano skuteczność metod PCA i SVD na każdym z trzech zbiorów danych zarówno przed, jak i po ich zastosowaniu. Celem testów była ocena, która z metod lepiej radzi sobie z redukcją wymiarowości, zachowując przy tym kluczowe informacje zawarte w danych. Testy miały na celu nie tylko sprawdzenie jak zmienia się wydajność algorytmów klasyfikacyjnych po redukcji wymiarów, ale również ocenę, jak poszczególne metody wpływają na jakość i separowalność danych w przestrzeni cech.</p>
</section>
<section id="wyniki-i-dyskusja" class="level1">
<h1>Wyniki i dyskusja</h1>
</section>
<section id="zbiór-danych-breast_cancer" class="level1">
<h1>Zbiór danych <code>breast_cancer</code></h1>
<section id="pca" class="level2">
<h2 class="anchored" data-anchor-id="pca">PCA</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="PCA/results/pca_bc.png" class="img-fluid figure-img"></p>
<figcaption>PCA breast cancer</figcaption>
</figure>
</div>
<p>Przedstawione zostały wyniki redukcji wymiarowości dla zestawu danych dotyczących raka piersi. Na podstawie lewego wykresu, który ilustruje wariancję wyjaśnioną przez poszczególne składowe, obserwujemy, że pierwszy komponent główny (PC1) odpowiada za 44% wariancji, a drugi komponent (PC2) za 19%. Łącznie daje to 63% całkowitej wyjaśnionej wariancji, co wskazuje, że te dwa komponenty zachowują większość informacji z zestawu danych. Wykres rozproszenia przedstawiający dane przed PCA ukazuje, że dane są stosunkowo dobrze zgrupowane, lecz rozproszone wzdłuż obu cech. Po transformacji PCA, wykres rozproszenia pokazuje dane w nowej przestrzeni, gdzie wyraźniej widoczna jest separacja między dwiema klasami, co może ułatwić dalszą klasyfikację.</p>
</section>
<section id="svd" class="level2">
<h2 class="anchored" data-anchor-id="svd">SVD</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="SVD/results/svd_bc.png" class="img-fluid figure-img"></p>
<figcaption>SVD breast cancer</figcaption>
</figure>
</div>
<p>SVD również zastosowano do tego samego zestawu danych. Podobnie jak w PCA, wartości wyjaśnionej wariancji dla komponentów są identyczne: 44% dla pierwszego i 19% dla drugiego komponentu, co łącznie daje 63% wyjaśnionej wariancji. Wykresy rozproszenia dla danych przed i po zastosowaniu SVD wykazują podobne charakterystyki co w PCA, sugerując, że po redukcji wymiarowości obserwacje z różnych klas są lepiej oddzielone.</p>
</section>
<section id="porównanie" class="level2">
<h2 class="anchored" data-anchor-id="porównanie">Porównanie</h2>
<p>Porównując wyniki PCA i SVD, zauważamy, że obie metody osiągnęły podobne poziomy wyjaśnionej wariancji. W obu przypadkach dwa komponenty (PC1 i PC2 lub ich odpowiedniki w SVD) skutecznie oddzielają klasy obserwacji na wykresach rozproszenia. Możemy wnioskować, że dla tego konkretnego zestawu danych, obie techniki są równie efektywne w redukcji wymiarów, zachowując przy tym kluczowe informacje niezbędne do identyfikacji i rozróżnienia klas. Wykresy rozproszenia wskazują na to, że dane są teraz lepiej przygotowane do dalszej analizy, takiej jak klasyfikacja czy grupowanie.</p>
</section>
</section>
<section id="zbiór-danych-iris" class="level1">
<h1>Zbiór danych <code>iris</code></h1>
<section id="pca-1" class="level2">
<h2 class="anchored" data-anchor-id="pca-1">PCA</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="PCA/results/pca_iris.png" class="img-fluid figure-img"></p>
<figcaption>PCA iris</figcaption>
</figure>
</div>
<p>Wykres wariancji wyjaśnionej przez PCA dla zestawu danych Iris prezentuje, że pierwszy główny komponent (PC1) wyjaśnia imponujące 73% wariancji, a drugi komponent (PC2) wyjaśnia dodatkowe 23%. Sumarycznie, te dwa komponenty wyjaśniają aż 96% wariancji danych. Jest to znaczący wynik, sugerujący, że redukcja wymiarów do tych dwóch komponentów zachowuje prawie całą strukturę danych. Wykres rozproszenia po lewej stronie ukazuje oryginalne dane w przestrzeni pierwszych dwóch cech, gdzie trzy gatunki irysów są już w miarę dobrze oddzielone. Natomiast wykres rozproszenia po prawej stronie, po transformacji PCA, wyraźnie oddziela gatunek setosa od pozostałych dwóch, co wskazuje na dużą efektywność PCA w izolowaniu tego gatunku na podstawie głównych komponentów.</p>
</section>
<section id="svd-1" class="level2">
<h2 class="anchored" data-anchor-id="svd-1">SVD</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="SVD/results/svd_iris.png" class="img-fluid figure-img"></p>
<figcaption>SVD iris</figcaption>
</figure>
</div>
<p>Rezultaty SVD prezentowane na wykresach dla tych samych danych Iris również wykazują, że pierwszy komponent ma 73% wariancji wyjaśnionej, a drugi 23%. Tak jak w PCA, suma wyjaśnionej wariancji to 96%. To wskazuje na podobieństwo efektów uzyskanych przez obie techniki. Wykres rozproszenia danych przed zastosowaniem SVD pokazuje rozłożenie cech bez żadnej transformacji. Natomiast po transformacji SVD, obserwujemy podobną klarowność separacji gatunku setosa jak w PCA, z pewnymi przesunięciami punktów dla pozostałych gatunków.</p>
</section>
<section id="porównanie-1" class="level2">
<h2 class="anchored" data-anchor-id="porównanie-1">Porównanie</h2>
<p>Analizując oba zestawy wyników, PCA i SVD wykazują niemal identyczną efektywność w wyjaśnieniu wariancji danych Iris. Obydwie metody z powodzeniem redukują dane do dwóch komponentów, zachowując przy tym główną strukturę danych i umożliwiając łatwą wizualizację separacji gatunków irysów. Transformacja PCA i SVD sprawia, że gatunek setosa jest łatwo rozróżnialny od versicolor i virginica, które są również lepiej oddzielone od siebie po transformacji niż w oryginalnych danych. Oba podejścia dowodzą, że dwie wymiary są wystarczające do reprezentacji złożoności danych i mogą być wykorzystane w dalszych analizach klasyfikacyjnych czy badaniach biologicznych.</p>
</section>
</section>
<section id="zbiór-danych-titanic" class="level1">
<h1>Zbiór danych <code>titanic</code></h1>
<section id="pca-2" class="level2">
<h2 class="anchored" data-anchor-id="pca-2">PCA</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="PCA/results/pca_titanic.png" class="img-fluid figure-img"></p>
<figcaption>PCA titanic</figcaption>
</figure>
</div>
<p>Dla zestawu danych związanych z Titanicem, pierwszy główny komponent (PC1) wyjaśnia 57% wariancji, a drugi komponent (PC2) odpowiada za 30% wariancji, co daje razem 87% wyjaśnionej wariancji. Wykres słupkowy jasno przedstawia tę dominację PC1 nad PC2 w zakresie wyjaśnianej wariancji. Przed transformacją PCA, oryginalne dane przedstawiające wiek i opłatę za bilet wydają się być szeroko rozproszone bez widocznej separacji między osobami, które przeżyły a tymi, które nie przeżyły. Po zastosowaniu PCA, dane są przedstawione w nowej przestrzeni zdefiniowanej przez PC1 i PC2, gdzie można zaobserwować pewną tendencję do grupowania, choć wciąż istnieje znaczne nakładanie się danych.</p>
</section>
<section id="svd-2" class="level2">
<h2 class="anchored" data-anchor-id="svd-2">SVD</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="SVD/results/svd_titanic.png" class="img-fluid figure-img"></p>
<figcaption>SVD titanic</figcaption>
</figure>
</div>
<p>Podobnie, po zastosowaniu SVD do tych samych danych Titanic, wyniki pokazują, że pierwszy komponent wyjaśnia 56% wariancji, a drugi 31%, co łącznie również daje 87% wyjaśnionej wariancji. Wykres przed transformacją SVD pokazuje podobny rozkład danych co w przypadku PCA. Po transformacji SVD, dane są prezentowane w nowym układzie współrzędnych, gdzie rozróżnienie między osobami, które przeżyły a tymi, które nie przeżyły, jest nieco bardziej zauważalne niż na oryginalnym wykresie rozproszenia.</p>
</section>
<section id="porównanie-2" class="level2">
<h2 class="anchored" data-anchor-id="porównanie-2">Porównanie</h2>
<p>Porównując wyniki PCA i SVD dla zestawu danych Titanic, obie techniki prezentują niemal identyczną zdolność do wyjaśnienia wariancji danych, z nieznacznymi różnicami w procentowych wartościach dla poszczególnych komponentów. Co istotne, transformacje te wydają się być użyteczne w potencjalnym wzmacnianiu wzorców rozróżniających przeżywalność, co może być kluczowe w dalszej analizie predykcyjnej czy klasyfikacyjnej. Choć dane po transformacji nadal wykazują nakładanie się klas, nowa przestrzeń komponentów może oferować lepszą możliwość separacji klasyfikatora.</p>
</section>
</section>
<section id="efekty-użycia-pca-i-svd-w-uczeniu-maszynowym" class="level1">
<h1>Efekty użycia PCA i SVD w uczeniu maszynowym</h1>
<section id="wstęp-1" class="level2">
<h2 class="anchored" data-anchor-id="wstęp-1">Wstęp</h2>
<p>Analiza składowych głównych (PCA) i rozkład według wartości osobliwych (SVD) to popularne techniki redukcji wymiarowości wykorzystywane w uczeniu maszynowym do przetwarzania danych o wysokim wymiarze. Te metody nie tylko przyspieszają obliczenia, ale mogą także pomagać w eliminacji szumu i korelacji między cechami.</p>
</section>
<section id="heloc---opis-zbioru-danych" class="level2">
<h2 class="anchored" data-anchor-id="heloc---opis-zbioru-danych">Heloc - opis zbioru danych</h2>
<p>Zbiór danych HELOC dostarczony przez FICO skupia się na liniach kredytowych (HELOC - Home Equity Line of Credit), które są zazwyczaj oferowane przez banki jako procent wartości kapitału własnego domu (różnica między obecną wartością rynkową domu a jego ceną zakupu). Klienci w tym zbiorze danych ubiegali się o kredyt w przedziale od 5 000 do 150 000 dolarów. Podstawowe zadanie polega na wykorzystaniu informacji o wnioskodawcy z jego raportu kredytowego do przewidywania, czy spłacą swoje konto HELOC w ciągu 2 lat. Zbiór zawiera różne cechy, takie jak szacunkowe ryzyko, liczba miesięcy od pierwszej i ostatniej transakcji, średni czas rozwiązania problemów, liczba zadowalających transakcji, procent legalnych transakcji, oraz inne wskaźniki finansowe i kredytowe.</p>
</section>
<section id="przegląd-eksperymentów" class="level2">
<h2 class="anchored" data-anchor-id="przegląd-eksperymentów">Przegląd Eksperymentów</h2>
<p>W przeprowadzonych eksperymentach zastosowano PCA i SVD do zbioru danych HELOC oraz zbioru Breast Cancer z repozytorium UCI. Do oceny modeli użyto klasyfikatora drzew decyzyjnych dla PCA oraz regresji logistycznej dla SVD i PCA.</p>
</section>
<section id="wyniki-i-analiza" class="level2">
<h2 class="anchored" data-anchor-id="wyniki-i-analiza">Wyniki i Analiza</h2>
<ol type="1">
<li>Zbiór danych <code>HELOC</code>:</li>
</ol>
<ul>
<li><strong>Przed PCA:</strong> Dokładność klasyfikacji wyniosła 62%.</li>
<li><strong>Po PCA:</strong> Dokładność klasyfikacji spadła do 56%.</li>
</ul>
<ol start="2" type="1">
<li>Zbiór danych <code>Breast Cancer (SVD)</code>:</li>
</ol>
<ul>
<li><strong>Przed SVD:</strong> Dokładność klasyfikacji wyniosła 95.61%.</li>
<li><strong>Po SVD:</strong> Dokładność klasyfikacji wzrosła do 97.37%.</li>
</ul>
<ol start="3" type="1">
<li>Zbiór danych <code>Breast Cancer (SVD)</code>:</li>
</ol>
<ul>
<li><strong>Przed PCA:</strong> Dokładność klasyfikacji wyniosła 95.61%.</li>
<li><strong>Po PCA:</strong> Dokładność klasyfikacji wzrosła do 96.49%.</li>
</ul>
</section>
<section id="dyskusja" class="level2">
<h2 class="anchored" data-anchor-id="dyskusja">Dyskusja</h2>
<p>Z przeprowadzonych eksperymentów wynika, że zastosowanie SVD i PCA może mieć różne efekty w zależności od rodzaju danych i użytego modelu:</p>
<ul>
<li><p>W przypadku zbioru danych HELOC zastosowanie PCA spowodowało spadek dokładności. Może to wynikać z utraty istotnych informacji, które są kluczowe dla procesu decyzyjnego w modelach drzewa decyzyjnego. PCA redukuje wymiarowość poprzez zachowanie głównych kierunków wariancji, co nie zawsze koreluje z zachowaniem najbardziej istotnych cech dla klasyfikacji.</p></li>
<li><p>W przypadku zbioru danych Breast Cancer, zarówno PCA, jak i SVD poprawiły dokładność klasyfikacji przy użyciu regresji logistycznej. Jest to szczególnie zauważalne dla SVD, które zachowało więcej istotnych informacji w mniejszej liczbie wymiarów. To wskazuje, że dla danych, które naturalnie zawierają mniej szumu i są bardziej skoncentrowane wokół głównych składowych, redukcja wymiarowości może faktycznie poprawić wydajność klasyfikacji.</p></li>
</ul>
</section>
<section id="wnioski" class="level2">
<h2 class="anchored" data-anchor-id="wnioski">Wnioski</h2>
<p>PCA i SVD mogą być cennymi narzędziami w przetwarzaniu danych, jednak ich efektywność jest silnie zależna od kontekstu zastosowania i charakterystyki danych. SVD wydaje się być bardziej odporny na utratę kluczowych informacji w kontekście stosowania w regresji logistycznej, podczas gdy PCA może być bardziej narażone na pomijanie ważnych cech w kontekstach, gdzie kierunki maksymalnej wariancji nie są związane z klasyfikacją.</p>
</section>
<section id="zalecenia" class="level2">
<h2 class="anchored" data-anchor-id="zalecenia">Zalecenia</h2>
<p>Przed zastosowaniem PCA czy SVD warto dokładnie analizować strukturę danych oraz prowadzić eksperymenty porównawcze, by wybrać metodę najbardziej odpowiednią dla danego problemu. Ponadto, warto rozważyć inne techniki redukcji wymiarów lub selekcji cech, które mogą lepiej odpowiadać na specyfikę danych, takie jak analiza składowych niezależnych (ICA) czy selekcja cech oparta na ważności atrybutów w modelach.</p>
</section>
</section>
<section id="section" class="level1">
<h1></h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>